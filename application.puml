@startuml Application Architecture
skinparam groupInheritance 2

package WSI << Window System Integration >>
{
    interface WindowI
    {
        + const vector<const char*> getRequiredExtensions() const

        + void makeContextCurrent()
        + void swapBuffers()
        + void pollEvents()
        + bool shouldClose() const
    }
    abstract WindowABC
    {
        - unique_ptr<Surface> m_surface
        - unique_ptr<SwapChain> m_swapchain
    }
    WindowI <|-- WindowABC

    class WindowSDL
    WindowABC <|-- WindowSDL
    class WindowGLFW
    WindowABC <|-- WindowGLFW

    interface WSILoaderI
}

package Client << Client code >>
{
    class Application
    {
        - unique_ptr<WindowABC> m_window
        - shared_ptr<Context> m_context
        - vector<shared_ptr<PhysicalDevice>> m_physicalDevices
        - vector<shared_ptr<LogicalDevice>> m_devices
        - shared_ptr<Scene> m_scene
        - shared_ptr<RendererABC> m_renderer
        - shared_ptr<VideoDecoder> m_decoder
    }
    Application *-- WindowABC
    class ArgParser
}

package Graphics
{
    enum GraphicsAPIE
    {
        OPENGL
        VULKAN
        DIRECT3D11
        DIRECT3D12
    }

    class Context
    {
        - vector<const char*> m_layers
        - vector<const char*> m_instanceExtensions
        + unique_ptr<Instance> m_instance

        + void enumerateAvailableInstanceLayers() const
        + enumerateAvailableInstanceExtensions() const
        + enumerateAvailablePhysicalDevices() const
    }
    Application *-- Context

    class Instance
    {
        - const Context& cx

        + void* getHandle() const
    }
    Context *-- Instance
    class InstanceVk
    {
        - unique_ptr<VkInstance> m_handle

        + VkInstance getHandle()
    }
    Instance <|-- InstanceVk
    class InstanceD3D12
    Instance <|-- InstanceD3D12
    class InstanceGL
    Instance <|-- InstanceGL

    class SwapChain
    {
        - vector<Image> m_images
        - vector<ImageView> m_imageViews
        - int m_bufferingCount
    }
    note bottom : buffering and presentation management
    WindowABC *-- SwapChain
    class Surface
    WindowABC *-- Surface
    struct SurfaceDetailsT << SwapChainCompatibilityT >>

    package Device
    {
        class PhysicalDevice
        {
            - shared_ptr<VkPhysicalDevice> m_handle
            + VkPhysicalDeviceProperties properties
            + VkPhysicalDeviceLimits limits

            + unique_ptr<LogicalDevice> createDevice() const
        }
        Application *-- PhysicalDevice
        class QueueFamily
        PhysicalDevice *-- QueueFamily

        class LogicalDevice << Device >>
        {
            - unique_ptr<VkDevice> m_handle
            - vector<const char*> m_deviceExtensions
            + Queue graphicsQueue
            + Queue presentQueue
            + unique_ptr<CommandPool> commandPool
        }
        Application *-- LogicalDevice
        LogicalDevice .up.> PhysicalDevice

        class Queue
        LogicalDevice *-right- Queue
    }

    package DeviceMemory
    {
        class Buffer
        class Image
        class ImageView
        note bottom : from swap chain or whatever image handling system
        class Sampler
    }

    package DeviceAsset
    {
        class Texture

        class Pipeline
        class Shader
        Pipeline *-- Shader
        class Descriptors
        Pipeline *-- Descriptors
    }

    package Renderer
    {
        abstract RendererABC
        {
            # shared_ptr<Pipeline> m_pipeline
            # shared_ptr<ImageView> m_imageView
            # unique_ptr<CommandPool> m_commandPool
            # vector<CommandBuffer> m_commandBuffers
            # int m_bufferingCount
        }
        note top of RendererABC : renders in an image with local command buffer
        note top of RendererABC : buffering management
        Application *-- RendererABC
        RendererABC *-- Pipeline
        RendererABC *-- ImageView
        class CommandPool
        RendererABC *-right- CommandPool
        class CommandBuffer
        RendererABC *-- CommandBuffer

        class DynamicRenderer
        note bottom : VK_KHR_dynamic_rendering extension
        RendererABC <|-- DynamicRenderer
        class LegacyRenderer << RenderPassBasedRenderer >>
        {
            - shared_ptr<RenderPass> m_renderPass
        }
        note left : with render passes
        RendererABC <|-- LegacyRenderer

        class RenderPass
        {
            - unique_ptr<Framebuffer> m_framebuffer
        }
        LegacyRenderer *-- RenderPass
        Pipeline .. RenderPass
        interface FramebufferI
        LegacyRenderer *-- FramebufferI
        FramebufferI ..> RenderPass
        class ImageFramebuffer
        {
            - shared_ptr<ImageView> m_imageView
            - shared_ptr<RenderPass> m_renderPass
        }
        FramebufferI <|-- ImageFramebuffer
        ImageFramebuffer *-- ImageView
        class ImageLessFramebuffer
        note bottom : VK_KHR_imageless_framebuffer extension
        FramebufferI <|-- ImageLessFramebuffer
    }
}

package EngineTypes
{
    class Color

    class Vertex
}

package HostMemory
{
    class ResourceManager
    interface ResourceI

    package Saved
    {
        class Mesh
        ResourceI <|-- Mesh
        class Scene
        ResourceI <|-- Scene
    }

    class AssetManager
    interface AssetI
}

package Video
{
    class VideoDecoder

    class HardwareVideoDecoder
    class Slot
    HardwareVideoDecoder *-right- Slot
    class Frame
    Slot *-right- Frame
}

@enduml